#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     gyro,           sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorFrontLeft, tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C1_2,     motorBackLeft, tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S1_C2_1,     motorBackRight, tmotorTetrix, PIDControl, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     motorFrontRight, tmotorTetrix, PIDControl, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Mecanum.c
A testfile for developing Mecanum drive capabilities.

LastUpdatedOn: 1/7
LastUpdatedBy: Clive
Status: Added "encoders" for fwd/side/rot, and outputs it. Haven't tried compiling.

TIP: when operating the ROBOTC FTC control thing, and the joystick input just doesn't work, 
try pressing All Stopped, then Teleop Ready and Teleop Running again, and it will work.
("If you believe in magic, you might just be coding in ROBOTC")
*/

#include "JoystickDriver.c"
#include "drivers/hitechnic-gyro.h"
#include "lib/T4Calculus.h"


float normalize(float x, float limit){
	if(abs(x) < abs(limit)) return 0; else return x;
}

float min(float a, float b){
	if(a < b) return a;
	else return b;
}
float max(float a, float b){
	if(a > b) return a;
	else return b;
}



/*
For rotate-while-translating: It's been done! https://www.youtube.com/watch?v=sM8cixsE5fo
t = ??? * currentOrientation; //Orientation is probably best measured with gyro; you COULD do it with integral(vRot) though.
[ vFwd  ] = [ cos(t)  -sin(t) ] * [ vFwd  ]     //depends on correct directionality of rotation, may have to switch +/-sin
[ vSide ]   [ sin(t)   cos(t) ]   [ vSide ]
Rotation matrix, which changes the requested vFwd and vSide so they are corrected for rotation. (keeps nonrotating frame of reference)
Random idea: https://www.youtube.com/watch?v=igaGWlMFdSw
*/
void rotateXYByDeg(float &x, float &y, float t){
	t = t * 3.141592653589 / 180.0;
	float oldx = x, oldy = y;
	//cos and sin are radians
	x = oldx * cos(t) - oldy * sin(t);
	y = oldx * sin(t) + oldy * cos(t);
}

//[[doesn't work yet!]]
//Translates while rotating. You have to call it in the while loop so it can constantly update itself.
//May be useful during autonomous, for speed (turn while moving and holding tube)
//May want to split the integration thingy off into a separate task that updates a global variable for theta.
void translateRotate(float vx, float vy, float vt, INTR& angleintr){
	  //(gyro reading is in degrees, so the integral is too)
	  float currtheta = integrate(angleintr, HTGYROreadRot(gyro));
	  rotateXYDeg(vx, vy, currtheta);
	  
	  //If it's potentially going above 95, block it from doing so; otherwise just let the speed be proportional to the joysticks.
	  //As a nice side effect, the division-by-zero isn't a problem anymore.
	  float JoyToWheel = min(95.0 / (abs(vx) + abs(vy) + abs(vt)), 1.0);

	  //we originally normalized for protecting motors from fluctuations; now we don't so motors don't lock up and drag.
	  motor[motorFrontLeft] = (JoyToWheel * (vy + vx + rotation));
	  motor[motorFrontRight] = (JoyToWheel * (vy - vx - rotation));
	  motor[motorBackLeft] = (JoyToWheel * (vy - vx + rotation));
	  motor[motorBackRight] = (JoyToWheel * (vy + vx - rotation));
}




task main(){
  //int vFwd, vSide, vRot; //Forward, Side, and Rotational velocities

  int x1, y1, x2, y2;

  //Assumes that it starts with forward pointing
  //in the desired permanent definition of "forward"
  //Integrator object for gyro angle and fwd, side, and rot positions
  INTR gyrointr; initIntr(gyrointr);
  INTR fwdintr; initIntr(fwdintr);
  INTR sideintr; initIntr(sideintr);
  INTR rotintr; initIntr(rotintr);

  //nMotorPIDSpeedCtrl? //neverest must have max output 78, because hitechnic encoders expect more ticks. http://www.cougarrobot.com/index.php?option=com_content&view=article&id=331%3Aandymark-neverest-motor-notes&catid=92%3Aftc-hardware&Itemid=140

  //Initiate gyro
  nSchedulePriority = kHighPriority;
  HTGYROstartCal(gyro);
  wait1Msec(1000); //and give it a bit of time

  while(1){
	  //ROTATION-CAPABLE AUGMENTED-TANK-DRIVE (see git history for previous versions)
	  
      getJoystickSettings(joystick);
	  
	  
	  //-------------GET JOYSTICK VALUES-------------//
	  x1 = normalize(joystick.joy1_x1,3);
	  y1 = normalize(joystick.joy1_y1,3);
	  x2 = normalize(joystick.joy1_x2,3);
	  y2 = normalize(joystick.joy1_y2,3);
	  
	  
	  //-------------CALCULATE INITIAL VALUES-------------//
	  //Get whatever values we need in the way we need for our particular control method.
	  //Takes the averages of the x and y values for the joysticks, and makes them the x/y translations, so it acts just like augmented-tank original.
	  float translationX = (x1 + x2)/2.0;
	  float translationY = (y1 + y2)/2.0;
	  //Determines the difference of the vectors to determine the rotation component.
	  float rotation = (y1 - y2)/2.0;
	  
	  
	  //-------------NORMALIZE-------------//
	  //If it's potentially going above 95 (our artificially imposed max-value), block it from doing so.
	  //Otherwise, just let the speed be proportional to the joystick value.
	  //As a nice side effect, the division-by-zero isn't a problem anymore.
	  float JoyToWheel = min(95.0 / (abs(translationY) + abs(translationX) + abs(rotation)), 1.0);
	  translationX *= JoyToWheel;
	  translationY *= JoyToWheel;
	  rotation *= JoyToWheel;
	  
	  
	  //-------------INTEGRATE COMPONENTS-------------//
	  //What even are the units for these? Gyro is in degrees, but fwd, side, rot are in... motorspeed*second. Whatever that is.
	  //AndyMark NeveRest motors supposedly do 129 RPM, but also 150RPM. The mecanums are ~10.5cm.
	  nxtDisplayTextLine(1,"'Encoders'");
	  nxtDisplayTextLine(2,"Gyro: %f", integrate(angleintr, HTGYROreadRot(gyro)));
	  nxtDisplayTextLine(3,"Fwd: %f", integrate(fwdintr, translationX));
	  nxtDisplayTextLine(4,"Side: %f", integrate(sideintr, translationY));
	  nxtDisplayTextLine(5,"Rot: %f", integrate(rotintr, rotation));
	  
	  //For encoding, reverse-solving the motor formulae:
	  //Would using these instead of using the original translationX translationY rotation values be more accurate?
	  //double deltaFwd = k * (deltaEncFL + deltaEncFR)/2.0;
	  //double deltaSide = k * (deltaEncFL - deltaEncBL)/2.0;
	  //double deltaRot = k * (deltaEncFR - deltaEncBL)/2.0;
	  
	  
	  //-------------ROTATION-INVARIANCE-------------// (has to be after integration of components)
	  //Gyro reading is in degrees, so the integral is too.
	  float currtheta = integrate(gyrointr, HTGYROreadRot(gyro));//If gyro turns out badly, just set this back to 0.
	  //Translation is now invariant to rotation. Thus, when you do the integrations above it'll actually be moving the thing forward.
	  rotateXYByDeg(translationX, translationY, currtheta);
	  
	  
	  //-------------SET MOTORS-------------//
	  //we originally normalized to protect motors from fluctuations; now we don't so motors don't lock up and drag.
	  motor[motorFrontLeft] = translationY + translationX + rotation;
	  motor[motorFrontRight] = translationY - translationX - rotation;
	  motor[motorBackLeft] = translationY - translationX + rotation;
	  motor[motorBackRight] = translationY + translationX - rotation;
	  
	  wait1Msec(10);
  }
}
